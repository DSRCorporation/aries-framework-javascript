diff --git a/dist/cjs/index.cjs b/dist/cjs/index.cjs
index 7d5f9b402a9b3a295fdb2719f3d8d8e771c26dcf..c52c67a3adc5b78a82745f466630fa8ee7ae7ed6 100644
--- a/dist/cjs/index.cjs
+++ b/dist/cjs/index.cjs
@@ -681,9 +681,8 @@ var createDID = async (options) => {
   if (options.witness && options.witness.witnesses.length > 0) {
     validateWitnessParameter(options.witness);
   }
-  const controller = `did:${METHOD}:${PLACEHOLDER}:${options.domain}`;
   const createdDate = createDate(options.created);
-  let { doc } = await createDIDDoc({ ...options, controller });
+  let { doc } = await createDIDDoc({ ...options });
   const params = {
     scid: PLACEHOLDER,
     updateKeys: options.updateKeys,
@@ -858,23 +857,27 @@ var resolveDIDFromLog = async (log, options = {}) => {
     }
     doc = clone(newDoc);
     did = doc.id;
-    doc.service = doc.service || [];
-    const baseUrl = getBaseUrl(did);
-    if (!doc.service.some((s) => s.id === "#files")) {
-      doc.service.push({
-        id: "#files",
-        type: "relativeRef",
-        serviceEndpoint: baseUrl
-      });
-    }
-    if (!doc.service.some((s) => s.id === "#whois")) {
-      doc.service.push({
-        "@context": "https://identity.foundation/linked-vp/contexts/v1",
-        id: "#whois",
-        type: "LinkedVerifiablePresentation",
-        serviceEndpoint: `${baseUrl}/whois.vp`
-      });
+
+    const baseUrl = did.startsWith('did:webvh:') ? getBaseUrl(did) : null;
+    if(baseUrl) {
+      doc.service = doc.service || [];
+      if (!doc.service.some((s) => s.id === "#files")) {
+        doc.service.push({
+          id: "#files",
+          type: "relativeRef",
+          serviceEndpoint: baseUrl
+        });
+      }
+      if (!doc.service.some((s) => s.id === "#whois")) {
+        doc.service.push({
+          "@context": "https://identity.foundation/linked-vp/contexts/v1",
+          id: "#whois",
+          type: "LinkedVerifiablePresentation",
+          serviceEndpoint: `${baseUrl}/whois.vp`
+        });
+      }
     }
+
     if (options.verificationMethod && findVerificationMethod(doc, options.verificationMethod)) {
       return { did, doc, meta };
     }
diff --git a/dist/browser/index.js b/dist/browser/index.js
index 7d887f8e04886904d5c3cfe77df7d013d9cf201d..4a93129381132304d22e59a74e895d00fe3ec8e0 100644
--- a/dist/browser/index.js
+++ b/dist/browser/index.js
@@ -1,6 +1,6 @@
 var{default:c_}=(()=>({}));import{canonicalize as X_}from"json-canonicalize";var U_=(_)=>{return Array.from(_).map((S)=>S.toString(16).padStart(2,"0")).join("")};var r=(_,S)=>{if(!Y.isBrowser)return Buffer.from(_,S);if(S==="base64"){let K=atob(_);return new Uint8Array(K.length).map((N,I)=>K.charCodeAt(I))}return new TextEncoder().encode(_)},c=(_,S)=>{if(!Y.isBrowser)return Buffer.from(_).toString(S);if(S==="hex")return U_(_);if(S==="base64"){let K=String.fromCharCode(..._);return btoa(K)}return new TextDecoder().decode(_)},C=(..._)=>{if(!Y.isBrowser)return Buffer.concat(_);let S=_.reduce((I,k)=>I+k.length,0),K=new Uint8Array(S),N=0;for(let I of _)K.set(I,N),N+=I.length;return K};var e=typeof window!=="undefined",u=(_)=>{if(e)return;try{return process?.env?.[_]}catch{return}},Y={getEnvValue:u,isBrowser:e,isTestEnvironment:u("NODE_ENV")==="test",logResolves:u("LOG_RESOLVES")==="true",getVerificationMethods:()=>{let _=u("DID_VERIFICATION_METHODS");if(!_)return[];try{let S=r(_,"base64");return JSON.parse(c(S))}catch{return[]}}};var o;((K)=>{K.BASE64URL_NO_PAD="u";K.BASE58_BTC="z"})(o||={});var g={["u"]:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",["z"]:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"};function Y_(_){return Buffer.from(_).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function Z_(_){let S=_.length%4===0?0:4-_.length%4,K=_.replace(/-/g,"+").replace(/_/g,"/")+"=".repeat(S),N=atob(K),I=new Uint8Array(N.length);for(let k=0;k<N.length;k++)I[k]=N.charCodeAt(k);return I}function E(_){let S=g.z,K=0;for(let k=0;k<_.length&&_[k]===0;k++)K++;let N=0n;for(let k=0;k<_.length;k++)N=N*256n+BigInt(_[k]);let I="";while(N>0n){let k=Number(N%58n);N=N/58n,I=S[k]+I}return"1".repeat(K)+I}function q_(_){let S=g.z,K=0;for(let k=0;k<_.length&&_[k]==="1";k++)K++;let N=0n;for(let k=K;k<_.length;k++){let x=_[k],O=S.indexOf(x);if(O===-1)throw new Error(`Invalid Base58 character: ${x}`);N=N*58n+BigInt(O)}let I=[];while(N>0n)I.unshift(Number(N%256n)),N=N/256n;return new Uint8Array([...new Array(K).fill(0),...I])}function G_(_,S="u"){let K;switch(S){case"u":K=Y_(_);break;case"z":K=E(_);break;default:throw new Error(`Unsupported multibase encoding: ${S}`)}return`${S}${K}`}function z(_){if(!_||_.length<2)throw new Error("Invalid multibase string: too short");let S=_[0],K=_.slice(1),N;switch(S){case"u":N=Z_(K);break;case"z":N=q_(K);break;default:throw new Error(`Unsupported multibase encoding prefix: ${S}`)}return{bytes:N,encoding:S}}var J_={[18]:32,[32]:48,[22]:32,[21]:48};function t(_){let S=[];while(_>=128)S.push(_&127|128),_>>>=7;return S.push(_&127),new Uint8Array(S)}function v(_,S){let K=J_[S];if(_.length!==K)throw new Error(`Invalid digest length for algorithm ${S.toString(16)}: expected ${K}, got ${_.length}`);let N=t(S),I=t(_.length),k=new Uint8Array(N.length+I.length+_.length);return k.set(N,0),k.set(I,N.length),k.set(_,N.length+I.length),k}import{sha256 as W_}from"@noble/hashes/sha2";async function Z(_){return W_(_)}var h=(_)=>JSON.parse(JSON.stringify(_)),p=(_)=>{let S=_.split(":");if(!_.startsWith("did:webvh:")||S.length<4)throw new Error(`${_} is not a valid did:webvh identifier`);let K=S.slice(3).join("/");return K=K.replace(/%2F/g,"/"),K=K.replace(/%3A/g,":"),`${K.includes("localhost")?"http":"https"}://${K}`},n=(_)=>{let S=p(_);if(S.indexOf("/",S.indexOf("://")+3)!==-1)return`${S}/did.jsonl`;return`${S}/.well-known/did.jsonl`};async function __(_,S=!1){try{if(S){let O=`./src/routes/${_.split(":").slice(4).join(":")||".well-known"}/did.jsonl`;try{let $=(await Bun.file(O).text()).trim();if(!$)return[];return $.split(`
 `).map((j)=>JSON.parse(j))}catch($){throw new Error(`Error reading local DID log: ${$}`)}}let K=n(_),N=await fetch(K);if(!N.ok)throw new Error(`HTTP error! status: ${N.status}`);let I=(await N.text()).trim();if(!I)throw new Error(`DID log not found for ${_}`);return I.split(`
 `).map((k)=>JSON.parse(k))}catch(K){throw console.error("Error fetching DID log:",K),K}}var H=(_)=>new Date(_??Date.now()).toISOString().slice(0,-5)+"Z";var f=async(_)=>{return _},P=async(_)=>{let S=X_(_),K=await Z(S),N=v(new Uint8Array(K),18);return E(N)},S_=async(_)=>{let S=await Z(_),K=v(new Uint8Array(S),18);return E(K)},m=async(_)=>{let{controller:S}=_,K=R_(_.verificationMethods,S),N={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/multikey/v1"],id:S,controller:S};if(K&&typeof K==="object"){if(K.verificationMethod)N.verificationMethod=K.verificationMethod;if(K.authentication)N.authentication=K.authentication;if(K.assertionMethod)N.assertionMethod=K.assertionMethod;if(K.keyAgreement)N.keyAgreement=K.keyAgreement;if(K.capabilityDelegation)N.capabilityDelegation=K.capabilityDelegation;if(K.capabilityInvocation)N.capabilityInvocation=K.capabilityInvocation}if(_.authentication)N.authentication=_.authentication;if(_.assertionMethod)N.assertionMethod=_.assertionMethod;if(_.keyAgreement)N.keyAgreement=_.keyAgreement;if(_.alsoKnownAs)N.alsoKnownAs=_.alsoKnownAs;return{doc:N}},Q_=(_=8)=>{let K="",N=36;for(let I=0;I<_;I++)K+="abcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(Math.random()*N));return K},D=(_,S)=>{return`${S??""}#${_.publicKeyMultibase?.slice(-8)||Q_(8)}`},R_=(_,S=null)=>{let K={verificationMethod:[],authentication:[],assertionMethod:[],keyAgreement:[],capabilityDelegation:[],capabilityInvocation:[]};if(!_||_.length===0)return K;let N=_.map((I)=>({...I,id:D(I,S)}));return K.verificationMethod=N,K.authentication=_.filter((I)=>!I.purpose||I.purpose==="authentication").map((I)=>D(I,S)),K.assertionMethod=_.filter((I)=>I.purpose==="assertionMethod").map((I)=>D(I,S)),K.keyAgreement=_.filter((I)=>I.purpose==="keyAgreement").map((I)=>D(I,S)),K.capabilityDelegation=_.filter((I)=>I.purpose==="capabilityDelegation").map((I)=>D(I,S)),K.capabilityInvocation=_.filter((I)=>I.purpose==="capabilityInvocation").map((I)=>D(I,S)),K},b=async(_)=>{try{if(_.startsWith("did:key:"))return{publicKeyMultibase:_.split("did:key:")[1].split("#")[0]};else if(_.startsWith("did:webvh:")){let S=n(_.split("#")[0]),N=(await(await fetch(S)).text()).trim().split(`
-`).map((k)=>JSON.parse(k)),{doc:I}=await M(N,{verificationMethod:_});return d(I,_)}throw new Error(`Verification method ${_} not found`)}catch(S){throw new Error(`Error resolving VM ${_}`)}},d=(_,S)=>{if(_.verificationMethod&&_.verificationMethod.some((N)=>N.id===S))return _.verificationMethod.find((N)=>N.id===S);let K=["authentication","assertionMethod","keyAgreement","capabilityInvocation","capabilityDelegation"];for(let N of K)if(_[N]){if(_[N].some((I)=>I.id===S))return _[N].find((I)=>I.id===S)}return null};async function K_(){let _=[];try{for(let S of Y.getVerificationMethods()){let K=S.controller||S.id.split("#")[0];_.push(K)}}catch(S){console.error("Error processing verification methods:",S)}return _}async function l(_){try{let S=n(_).replace("did.jsonl","did-witness.json"),K=await fetch(S);if(!K.ok)return[];return await K.json()}catch(S){return console.error("Error fetching witness proofs:",S),[]}}var W="{SCID}",N_="webvh";var a="did:webvh:0.5";import{canonicalize as k_}from"json-canonicalize";import{canonicalize as I_}from"json-canonicalize";function y(_){if(!_.threshold||_.threshold<1)throw new Error("Witness threshold must be at least 1");if(!_.witnesses||!Array.isArray(_.witnesses)||_.witnesses.length===0)throw new Error("Witness list cannot be empty");for(let S of _.witnesses){if(!S.id.startsWith("did:key:"))throw new Error("Witness DIDs must be did:key format");if(typeof S.weight!=="number"||S.weight<1)throw new Error("Witness weight must be a positive number")}}async function x_(_,S,K,N){if(!N)throw new Error("Verifier implementation is required");let I=0,k=new Set;for(let x of S)for(let O of x.proof){if(O.cryptosuite!=="eddsa-jcs-2022")throw new Error("Invalid witness proof cryptosuite");let $=K.witnesses.find((j)=>O.verificationMethod.startsWith(j.id));if(!$)throw new Error("Proof from unauthorized witness");if(k.has($.id))continue;try{let j=await b(O.verificationMethod);if(!j)throw new Error(`Verification Method ${O.verificationMethod} not found`);let V;try{V=z(j.publicKeyMultibase).bytes}catch(J){throw new Error(`Failed to decode public key: ${J.message}`)}if(V.length!==34)throw new Error(`Invalid public key length ${V.length} (should be 34 bytes)`);let{proofValue:w,...X}=O,R=I_({versionId:_.versionId}),q=I_(X),T=await Z(R),Q=await Z(q),F=C(Q,T),U;try{U=z(w).bytes}catch(J){throw new Error(`Failed to decode signature: ${J.message}`)}let G=!1,A=3;for(let J=0;J<A;J++)try{if(G=await N.verify(U,F,V.slice(2)),G)break;if(J<A-1)await new Promise((L)=>setTimeout(L,10))}catch(L){if(console.error(`Verification attempt ${J+1} failed:`,L),J===A-1)throw L;await new Promise((j_)=>setTimeout(j_,10))}if(!G)throw console.error("Signature verification failed:"),console.error("- Signature:",Buffer.from(U).toString("hex").substring(0,30)+"..."),console.error("- Message:",Buffer.from(F).toString("hex").substring(0,30)+"..."),console.error("- Public Key:",Buffer.from(V.slice(2)).toString("hex").substring(0,30)+"..."),new Error("Invalid witness proof signature");I+=$.weight,k.add($.id)}catch(j){throw new Error(`Invalid witness proof: ${j.message}`)}}if(I<K.threshold)throw new Error(`Witness threshold not met: got ${I}, need ${K.threshold}`)}var T_=(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_KEY_IS_AUTHORIZED")==="true")return!0;if(_.startsWith("did:key:")){let N=_.split("did:key:")[1].split("#")[0];return S.some((k)=>{let x=k;if(k.startsWith("did:key:"))x=k.split("did:key:")[1].split("#")[0];return x===N})}return!1},A_=(_,S)=>{if(Y.getEnvValue("IGNORE_WITNESS_IS_AUTHORIZED")==="true")return!0;if(_.startsWith("did:webvh:")){let K=_.split("#")[0];return S.includes(K)}return!1},B=async(_,S,K,N,I)=>{if(Y.getEnvValue("IGNORE_ASSERTION_DOCUMENT_STATE_IS_VALID")==="true")return!0;if(!I)throw new Error("Verifier implementation is required");let{proof:k,...x}=_;if(!Array.isArray(k))k=[k];if(K&&K.witnesses.length>0){if(!N)y(K)}for(let O=0;O<k.length;O++){let $=k[O];if($.verificationMethod.startsWith("did:key:")){if(!T_($.verificationMethod,S))throw new Error(`Key ${$.verificationMethod} is not authorized to update.`)}else if($.verificationMethod.startsWith("did:webvh:")){if(K&&K.witnesses.length>0&&!A_($.verificationMethod,K.witnesses.map((U)=>U.id)))throw new Error(`Key ${$.verificationMethod} is not from an authorized witness.`)}else throw new Error(`Unsupported verification method: ${$.verificationMethod}`);if($.type!=="DataIntegrityProof")throw new Error(`Unknown proof type ${$.type}`);if($.proofPurpose!=="authentication"&&$.proofPurpose!=="assertionMethod")throw new Error(`Unknown proof purpose ${$.proofPurpose}`);if($.cryptosuite!=="eddsa-jcs-2022")throw new Error(`Unknown cryptosuite ${$.cryptosuite}`);let j=await b($.verificationMethod);if(!j)throw new Error(`Verification Method ${$.verificationMethod} not found`);let V=z(j.publicKeyMultibase).bytes;if(V[0]!==237||V[1]!==1)throw new Error("multiKey doesn't include ed25519 header (0xed01)");let{proofValue:w,...X}=$,R=z(w).bytes,q=await Z(k_(x)),T=await Z(k_(X)),Q=C(T,q);if(!await I.verify(R,Q,V.slice(2)))throw new Error(`Proof ${O} failed verification`)}return!0},$_=(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_HASH_CHAIN_IS_VALID")==="true")return!0;return _===S},O_=async(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_NEW_KEYS_ARE_VALID")==="true")return!0;if(S.length>0)for(let K of _){let N=await S_(K);if(!S.includes(N))throw new Error(`Invalid update key ${N}. Not found in nextKeyHashes ${S}`)}return!0},i=async(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_SCID_IS_FROM_HASH")==="true")return!0;return _===await f(S)};var z_=async(_)=>{if(!_.updateKeys)throw new Error("Update keys not supplied");if(_.witness&&_.witness.witnesses.length>0)y(_.witness);let S=`did:${N_}:${W}:${_.domain}`,K=H(_.created),{doc:N}=await m({..._,controller:S}),I={scid:W,updateKeys:_.updateKeys,portable:_.portable??!1,nextKeyHashes:_.nextKeyHashes??[],..._.witness?{witness:_.witness}:{},deactivated:!1},k={versionId:W,versionTime:K,parameters:{method:a,...I},state:N},x=await P(k);I.scid=await f(x),k.state=N;let O=JSON.parse(JSON.stringify(k).replaceAll(W,I.scid)),$=await P(O);O.versionId=`1-${$}`;let j=await _.signer.sign({document:O,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:K,proofPurpose:"assertionMethod"}}),V=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:K,proofPurpose:"assertionMethod",proofValue:j.proofValue}];if(O.proof=V,!await B({...O,versionId:`1-${$}`,proof:O.proof},I.updateKeys,I.witness,!0,_.verifier))throw new Error(`version ${O.versionId} is invalid.`);return{did:O.state.id,doc:O.state,meta:{versionId:O.versionId,created:O.versionTime,updated:O.versionTime,prerotation:(I.nextKeyHashes?.length??0)>0,...I},log:[O]}},P_=async(_,S={})=>{let N=(await K_()).includes(_),I=await __(_,N);if(I.length===0)throw new Error(`DID ${_} not found`);let k=await M(I,{...S}),x=_.split(":");if(x.length>=3){let O=x[2],$=k.meta.previousLogEntryHash;if($&&!await i(O,$))throw new Error(`SCID in DID '${O}' not derived from log entry hash '${$}'`)}return{...k,controlled:N}},M=async(_,S={})=>{if(S.verificationMethod&&(S.versionNumber||S.versionId))throw new Error("Cannot specify both verificationMethod and version number/id");let K=h(_),N=K[0].parameters.method;if(N!==a)throw new Error(`'${N}' protocol unknown.`);let I={},k="",x={versionId:"",created:"",updated:"",previousLogEntryHash:"",scid:"",prerotation:!1,portable:!1,nextKeyHashes:[],deactivated:!1,updateKeys:[],witness:void 0},O="",$=0;while($<K.length){let{versionId:j,versionTime:V,parameters:w,state:X,proof:R}=K[$],[q,T]=j.split("-");if(parseInt(q)!==$+1)throw new Error(`version '${q}' in log doesn't match expected '${$+1}'.`);x.versionId=j,x.updated=V;let Q=X;if(q==="1"){x.created=V,Q=X,O=Q.id.split(":").at(-1),x.scid=w.scid,x.portable=w.portable??x.portable,x.updateKeys=w.updateKeys,x.nextKeyHashes=w.nextKeyHashes||[],x.prerotation=x.nextKeyHashes.length>0,x.witness=w.witness||x.witness,x.nextKeyHashes=w.nextKeyHashes??[];let U={versionId:W,versionTime:x.created,parameters:JSON.parse(JSON.stringify(w).replaceAll(x.scid,W)),state:JSON.parse(JSON.stringify(Q).replaceAll(x.scid,W))},G=await P(U);if(x.previousLogEntryHash=G,!await i(x.scid,G))throw new Error(`SCID '${x.scid}' not derived from logEntryHash '${G}'`);let A=JSON.parse(JSON.stringify(U).replaceAll(W,x.scid)),J=await P(A);if(!await B({...A,versionId:`1-${J}`,proof:R},x.updateKeys,x.witness,!1,S.verifier))throw new Error(`version ${x.versionId} failed verification of the proof.`)}else{let U=Q.id.split(":").at(-1);if(!x.portable&&U!==O)throw new Error("Cannot move DID: portability is disabled");else if(U!==O)O=U;let G=x.prerotation?w.updateKeys:x.updateKeys;if(!await B(K[$],G,x.witness,!1,S.verifier))throw new Error(`version ${x.versionId} failed verification of the proof.`);if(!$_(`${$+1}-${T}`,j))throw new Error(`Hash chain broken at '${x.versionId}'`);if(x.prerotation)await O_(w.updateKeys??[],x.nextKeyHashes??[]);if(w.updateKeys)x.updateKeys=w.updateKeys;if(w.deactivated===!0)x.deactivated=!0;if(w.nextKeyHashes)x.nextKeyHashes=w.nextKeyHashes,x.prerotation=!0;else x.nextKeyHashes=[],x.prerotation=!1;if("witness"in w)x.witness=w.witness;else if(w.witnesses)x.witness={witnesses:w.witnesses,threshold:w.witnessThreshold||w.witnesses.length}}I=h(Q),k=I.id,I.service=I.service||[];let F=p(k);if(!I.service.some((U)=>U.id==="#files"))I.service.push({id:"#files",type:"relativeRef",serviceEndpoint:F});if(!I.service.some((U)=>U.id==="#whois"))I.service.push({"@context":"https://identity.foundation/linked-vp/contexts/v1",id:"#whois",type:"LinkedVerifiablePresentation",serviceEndpoint:`${F}/whois.vp`});if(S.verificationMethod&&d(I,S.verificationMethod))return{did:k,doc:I,meta:x};if(S.versionNumber===parseInt(q)||S.versionId===x.versionId)return{did:k,doc:I,meta:x};if(S.versionTime&&S.versionTime>new Date(x.updated)){if(K[$+1]&&S.versionTime<new Date(K[$+1].versionTime))return{did:k,doc:I,meta:x};else if(!K[$+1])return{did:k,doc:I,meta:x}}if(x.witness&&$===K.length-1){if(!S.witnessProofs)S.witnessProofs=await l(k);let U=S.witnessProofs.filter((G)=>{return G.versionId===x.versionId});if(U.length>0)await x_(K[$],U,x.witness,S.verifier)}$++}return{did:k,doc:I,meta:x}},F_=async(_)=>{let S=_.log,K=S[S.length-1],N=(await M(S,{verifier:_.verifier})).meta;if(N.deactivated)throw new Error("Cannot update deactivated DID");let I=S.length+1,k=H(_.updated),x={updateKeys:_.updateKeys??[],nextKeyHashes:_.nextKeyHashes??[],..._.witness===null?{witness:null}:_.witness!==void 0?{witnesses:_.witness?.witnesses||[],witnessThreshold:_.witness?.threshold||0}:{}},{doc:O}=await m({..._,controller:_.controller||K.state.id||"",context:_.context||K.state["@context"],domain:_.domain??K.state.id?.split(":").at(-1)??"",updateKeys:_.updateKeys??[],verificationMethods:_.verificationMethods??[]});if(_.services&&_.services.length>0)O.service=_.services;if(_.assertionMethod)O.assertionMethod=_.assertionMethod;if(_.keyAgreement)O.keyAgreement=_.keyAgreement;let $={versionId:W,versionTime:k,parameters:x,state:O},j=await P($),V=`${I}-${j}`,w={...$,versionId:V},X=await _.signer.sign({document:w,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod"}}),R=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod",proofValue:X.proofValue}];if(w.proof=R,!await B(w,N.updateKeys,N.witness,!0,_.verifier))throw new Error(`version ${w.versionId} is invalid.`);let T={...N,versionId:w.versionId,updated:w.versionTime,prerotation:(x.nextKeyHashes?.length??0)>0,...x};return{did:w.state.id,doc:w.state,meta:T,log:[...S,w]}},C_=async(_)=>{let S=_.log,K=S[S.length-1],N=(await M(S,{verifier:_.verifier})).meta;if(N.deactivated)throw new Error("DID already deactivated");let I=S.length+1,k=H(),x={updateKeys:_.updateKeys??N.updateKeys,deactivated:!0},O={versionId:W,versionTime:k,parameters:x,state:K.state},$=await P(O),j=`${I}-${$}`,V={...O,versionId:j},w=await _.signer.sign({document:V,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod"}}),X=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod",proofValue:w.proofValue}];if(V.proof=X,!await B(V,N.updateKeys,N.witness,!0,_.verifier))throw new Error(`version ${V.versionId} is invalid.`);let q={...N,versionId:V.versionId,updated:V.versionTime,deactivated:!0,updateKeys:x.updateKeys};return{did:V.state.id,doc:V.state,meta:q,log:[...S,V]}};import{canonicalize as w_}from"json-canonicalize";var s=(_)=>{return{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_,created:H(),proofPurpose:"assertionMethod"}},D_=async(_,S)=>{let K=await Z(w_(_)),N=await Z(w_(S));return C(N,K)};class V_{verificationMethod;useStaticId;constructor(_){this.verificationMethod=_.verificationMethod,this.useStaticId=_.useStaticId!==void 0?_.useStaticId:!0}getVerificationMethodId(){return this.useStaticId?`did:key:${this.verificationMethod.publicKeyMultibase}#${this.verificationMethod.publicKeyMultibase}`:this.verificationMethod.id||""}}var H_=(_,S)=>{return async(K)=>{try{let N=s(S),I=await _.sign({document:K,proof:N});return N.proofValue=I.proofValue,{...K,proof:N}}catch(N){throw console.error(N),new Error(`Document signing failure: ${N.message||N}`)}}},M_=(_,S=!0)=>{return console.warn("createSigner is deprecated. Use createDocumentSigner with your own Signer implementation instead."),async(K)=>{try{let N=S?`did:key:${_.publicKeyMultibase}#${_.publicKeyMultibase}`:_.id||"",I=s(N);throw new Error("createSigner is deprecated. Implement your own Signer and use createDocumentSigner instead.")}catch(N){throw console.error(N),new Error(`Document signing failure: ${N.message||N}`)}}};export{F_ as updateDID,M as resolveDIDFromLog,P_ as resolveDID,D_ as prepareDataForSigning,G_ as multibaseEncode,z as multibaseDecode,C_ as deactivateDID,M_ as createSigner,s as createProof,H_ as createDocumentSigner,z_ as createDID,o as MultibaseEncoding,V_ as AbstractCrypto};
+`).map((k)=>JSON.parse(k)),{doc:I}=await M(N,{verificationMethod:_});return d(I,_)}throw new Error(`Verification method ${_} not found`)}catch(S){throw new Error(`Error resolving VM ${_}`)}},d=(_,S)=>{if(_.verificationMethod&&_.verificationMethod.some((N)=>N.id===S))return _.verificationMethod.find((N)=>N.id===S);let K=["authentication","assertionMethod","keyAgreement","capabilityInvocation","capabilityDelegation"];for(let N of K)if(_[N]){if(_[N].some((I)=>I.id===S))return _[N].find((I)=>I.id===S)}return null};async function K_(){let _=[];try{for(let S of Y.getVerificationMethods()){let K=S.controller||S.id.split("#")[0];_.push(K)}}catch(S){console.error("Error processing verification methods:",S)}return _}async function l(_){try{let S=n(_).replace("did.jsonl","did-witness.json"),K=await fetch(S);if(!K.ok)return[];return await K.json()}catch(S){return console.error("Error fetching witness proofs:",S),[]}}var W="{SCID}",N_="webvh";var a="did:webvh:0.5";import{canonicalize as k_}from"json-canonicalize";import{canonicalize as I_}from"json-canonicalize";function y(_){if(!_.threshold||_.threshold<1)throw new Error("Witness threshold must be at least 1");if(!_.witnesses||!Array.isArray(_.witnesses)||_.witnesses.length===0)throw new Error("Witness list cannot be empty");for(let S of _.witnesses){if(!S.id.startsWith("did:key:"))throw new Error("Witness DIDs must be did:key format");if(typeof S.weight!=="number"||S.weight<1)throw new Error("Witness weight must be a positive number")}}async function x_(_,S,K,N){if(!N)throw new Error("Verifier implementation is required");let I=0,k=new Set;for(let x of S)for(let O of x.proof){if(O.cryptosuite!=="eddsa-jcs-2022")throw new Error("Invalid witness proof cryptosuite");let $=K.witnesses.find((j)=>O.verificationMethod.startsWith(j.id));if(!$)throw new Error("Proof from unauthorized witness");if(k.has($.id))continue;try{let j=await b(O.verificationMethod);if(!j)throw new Error(`Verification Method ${O.verificationMethod} not found`);let V;try{V=z(j.publicKeyMultibase).bytes}catch(J){throw new Error(`Failed to decode public key: ${J.message}`)}if(V.length!==34)throw new Error(`Invalid public key length ${V.length} (should be 34 bytes)`);let{proofValue:w,...X}=O,R=I_({versionId:_.versionId}),q=I_(X),T=await Z(R),Q=await Z(q),F=C(Q,T),U;try{U=z(w).bytes}catch(J){throw new Error(`Failed to decode signature: ${J.message}`)}let G=!1,A=3;for(let J=0;J<A;J++)try{if(G=await N.verify(U,F,V.slice(2)),G)break;if(J<A-1)await new Promise((L)=>setTimeout(L,10))}catch(L){if(console.error(`Verification attempt ${J+1} failed:`,L),J===A-1)throw L;await new Promise((j_)=>setTimeout(j_,10))}if(!G)throw console.error("Signature verification failed:"),console.error("- Signature:",Buffer.from(U).toString("hex").substring(0,30)+"..."),console.error("- Message:",Buffer.from(F).toString("hex").substring(0,30)+"..."),console.error("- Public Key:",Buffer.from(V.slice(2)).toString("hex").substring(0,30)+"..."),new Error("Invalid witness proof signature");I+=$.weight,k.add($.id)}catch(j){throw new Error(`Invalid witness proof: ${j.message}`)}}if(I<K.threshold)throw new Error(`Witness threshold not met: got ${I}, need ${K.threshold}`)}var T_=(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_KEY_IS_AUTHORIZED")==="true")return!0;if(_.startsWith("did:key:")){let N=_.split("did:key:")[1].split("#")[0];return S.some((k)=>{let x=k;if(k.startsWith("did:key:"))x=k.split("did:key:")[1].split("#")[0];return x===N})}return!1},A_=(_,S)=>{if(Y.getEnvValue("IGNORE_WITNESS_IS_AUTHORIZED")==="true")return!0;if(_.startsWith("did:webvh:")){let K=_.split("#")[0];return S.includes(K)}return!1},B=async(_,S,K,N,I)=>{if(Y.getEnvValue("IGNORE_ASSERTION_DOCUMENT_STATE_IS_VALID")==="true")return!0;if(!I)throw new Error("Verifier implementation is required");let{proof:k,...x}=_;if(!Array.isArray(k))k=[k];if(K&&K.witnesses.length>0){if(!N)y(K)}for(let O=0;O<k.length;O++){let $=k[O];if($.verificationMethod.startsWith("did:key:")){if(!T_($.verificationMethod,S))throw new Error(`Key ${$.verificationMethod} is not authorized to update.`)}else if($.verificationMethod.startsWith("did:webvh:")){if(K&&K.witnesses.length>0&&!A_($.verificationMethod,K.witnesses.map((U)=>U.id)))throw new Error(`Key ${$.verificationMethod} is not from an authorized witness.`)}else throw new Error(`Unsupported verification method: ${$.verificationMethod}`);if($.type!=="DataIntegrityProof")throw new Error(`Unknown proof type ${$.type}`);if($.proofPurpose!=="authentication"&&$.proofPurpose!=="assertionMethod")throw new Error(`Unknown proof purpose ${$.proofPurpose}`);if($.cryptosuite!=="eddsa-jcs-2022")throw new Error(`Unknown cryptosuite ${$.cryptosuite}`);let j=await b($.verificationMethod);if(!j)throw new Error(`Verification Method ${$.verificationMethod} not found`);let V=z(j.publicKeyMultibase).bytes;if(V[0]!==237||V[1]!==1)throw new Error("multiKey doesn't include ed25519 header (0xed01)");let{proofValue:w,...X}=$,R=z(w).bytes,q=await Z(k_(x)),T=await Z(k_(X)),Q=C(T,q);if(!await I.verify(R,Q,V.slice(2)))throw new Error(`Proof ${O} failed verification`)}return!0},$_=(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_HASH_CHAIN_IS_VALID")==="true")return!0;return _===S},O_=async(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_NEW_KEYS_ARE_VALID")==="true")return!0;if(S.length>0)for(let K of _){let N=await S_(K);if(!S.includes(N))throw new Error(`Invalid update key ${N}. Not found in nextKeyHashes ${S}`)}return!0},i=async(_,S)=>{if(Y.getEnvValue("IGNORE_ASSERTION_SCID_IS_FROM_HASH")==="true")return!0;return _===await f(S)};var z_=async(_)=>{if(!_.updateKeys)throw new Error("Update keys not supplied");if(_.witness&&_.witness.witnesses.length>0)y(_.witness);let S=`did:${N_}:${W}:${_.domain}`,K=H(_.created),{doc:N}=await m({..._}),I={scid:W,updateKeys:_.updateKeys,portable:_.portable??!1,nextKeyHashes:_.nextKeyHashes??[],..._.witness?{witness:_.witness}:{},deactivated:!1},k={versionId:W,versionTime:K,parameters:{method:a,...I},state:N},x=await P(k);I.scid=await f(x),k.state=N;let O=JSON.parse(JSON.stringify(k).replaceAll(W,I.scid)),$=await P(O);O.versionId=`1-${$}`;let j=await _.signer.sign({document:O,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:K,proofPurpose:"assertionMethod"}}),V=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:K,proofPurpose:"assertionMethod",proofValue:j.proofValue}];if(O.proof=V,!await B({...O,versionId:`1-${$}`,proof:O.proof},I.updateKeys,I.witness,!0,_.verifier))throw new Error(`version ${O.versionId} is invalid.`);return{did:O.state.id,doc:O.state,meta:{versionId:O.versionId,created:O.versionTime,updated:O.versionTime,prerotation:(I.nextKeyHashes?.length??0)>0,...I},log:[O]}},P_=async(_,S={})=>{let N=(await K_()).includes(_),I=await __(_,N);if(I.length===0)throw new Error(`DID ${_} not found`);let k=await M(I,{...S}),x=_.split(":");if(x.length>=3){let O=x[2],$=k.meta.previousLogEntryHash;if($&&!await i(O,$))throw new Error(`SCID in DID '${O}' not derived from log entry hash '${$}'`)}return{...k,controlled:N}},M=async(_,S={})=>{if(S.verificationMethod&&(S.versionNumber||S.versionId))throw new Error("Cannot specify both verificationMethod and version number/id");let K=h(_),N=K[0].parameters.method;if(N!==a)throw new Error(`'${N}' protocol unknown.`);let I={},k="",x={versionId:"",created:"",updated:"",previousLogEntryHash:"",scid:"",prerotation:!1,portable:!1,nextKeyHashes:[],deactivated:!1,updateKeys:[],witness:void 0},O="",$=0;while($<K.length){let{versionId:j,versionTime:V,parameters:w,state:X,proof:R}=K[$],[q,T]=j.split("-");if(parseInt(q)!==$+1)throw new Error(`version '${q}' in log doesn't match expected '${$+1}'.`);x.versionId=j,x.updated=V;let Q=X;if(q==="1"){x.created=V,Q=X,O=Q.id.split(":").at(-1),x.scid=w.scid,x.portable=w.portable??x.portable,x.updateKeys=w.updateKeys,x.nextKeyHashes=w.nextKeyHashes||[],x.prerotation=x.nextKeyHashes.length>0,x.witness=w.witness||x.witness,x.nextKeyHashes=w.nextKeyHashes??[];let U={versionId:W,versionTime:x.created,parameters:JSON.parse(JSON.stringify(w).replaceAll(x.scid,W)),state:JSON.parse(JSON.stringify(Q).replaceAll(x.scid,W))},G=await P(U);if(x.previousLogEntryHash=G,!await i(x.scid,G))throw new Error(`SCID '${x.scid}' not derived from logEntryHash '${G}'`);let A=JSON.parse(JSON.stringify(U).replaceAll(W,x.scid)),J=await P(A);if(!await B({...A,versionId:`1-${J}`,proof:R},x.updateKeys,x.witness,!1,S.verifier))throw new Error(`version ${x.versionId} failed verification of the proof.`)}else{let U=Q.id.split(":").at(-1);if(!x.portable&&U!==O)throw new Error("Cannot move DID: portability is disabled");else if(U!==O)O=U;let G=x.prerotation?w.updateKeys:x.updateKeys;if(!await B(K[$],G,x.witness,!1,S.verifier))throw new Error(`version ${x.versionId} failed verification of the proof.`);if(!$_(`${$+1}-${T}`,j))throw new Error(`Hash chain broken at '${x.versionId}'`);if(x.prerotation)await O_(w.updateKeys??[],x.nextKeyHashes??[]);if(w.updateKeys)x.updateKeys=w.updateKeys;if(w.deactivated===!0)x.deactivated=!0;if(w.nextKeyHashes)x.nextKeyHashes=w.nextKeyHashes,x.prerotation=!0;else x.nextKeyHashes=[],x.prerotation=!1;if("witness"in w)x.witness=w.witness;else if(w.witnesses)x.witness={witnesses:w.witnesses,threshold:w.witnessThreshold||w.witnesses.length}}I=h(Q),k=I.id;let F=k.startsWith('did:webvh:')?p(k):null;if(F)I.service=I.service||[];if(F && !I.service.some((U)=>U.id==="#files"))I.service.push({id:"#files",type:"relativeRef",serviceEndpoint:F});if(F && !I.service.some((U)=>U.id==="#whois"))I.service.push({"@context":"https://identity.foundation/linked-vp/contexts/v1",id:"#whois",type:"LinkedVerifiablePresentation",serviceEndpoint:`${F}/whois.vp`});if(S.verificationMethod&&d(I,S.verificationMethod))return{did:k,doc:I,meta:x};if(S.versionNumber===parseInt(q)||S.versionId===x.versionId)return{did:k,doc:I,meta:x};if(S.versionTime&&S.versionTime>new Date(x.updated)){if(K[$+1]&&S.versionTime<new Date(K[$+1].versionTime))return{did:k,doc:I,meta:x};else if(!K[$+1])return{did:k,doc:I,meta:x}}if(x.witness&&$===K.length-1){if(!S.witnessProofs)S.witnessProofs=await l(k);let U=S.witnessProofs.filter((G)=>{return G.versionId===x.versionId});if(U.length>0)await x_(K[$],U,x.witness,S.verifier)}$++}return{did:k,doc:I,meta:x}},F_=async(_)=>{let S=_.log,K=S[S.length-1],N=(await M(S,{verifier:_.verifier})).meta;if(N.deactivated)throw new Error("Cannot update deactivated DID");let I=S.length+1,k=H(_.updated),x={updateKeys:_.updateKeys??[],nextKeyHashes:_.nextKeyHashes??[],..._.witness===null?{witness:null}:_.witness!==void 0?{witnesses:_.witness?.witnesses||[],witnessThreshold:_.witness?.threshold||0}:{}},{doc:O}=await m({..._,controller:_.controller||K.state.id||"",context:_.context||K.state["@context"],domain:_.domain??K.state.id?.split(":").at(-1)??"",updateKeys:_.updateKeys??[],verificationMethods:_.verificationMethods??[]});if(_.services&&_.services.length>0)O.service=_.services;if(_.assertionMethod)O.assertionMethod=_.assertionMethod;if(_.keyAgreement)O.keyAgreement=_.keyAgreement;let $={versionId:W,versionTime:k,parameters:x,state:O},j=await P($),V=`${I}-${j}`,w={...$,versionId:V},X=await _.signer.sign({document:w,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod"}}),R=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod",proofValue:X.proofValue}];if(w.proof=R,!await B(w,N.updateKeys,N.witness,!0,_.verifier))throw new Error(`version ${w.versionId} is invalid.`);let T={...N,versionId:w.versionId,updated:w.versionTime,prerotation:(x.nextKeyHashes?.length??0)>0,...x};return{did:w.state.id,doc:w.state,meta:T,log:[...S,w]}},C_=async(_)=>{let S=_.log,K=S[S.length-1],N=(await M(S,{verifier:_.verifier})).meta;if(N.deactivated)throw new Error("DID already deactivated");let I=S.length+1,k=H(),x={updateKeys:_.updateKeys??N.updateKeys,deactivated:!0},O={versionId:W,versionTime:k,parameters:x,state:K.state},$=await P(O),j=`${I}-${$}`,V={...O,versionId:j},w=await _.signer.sign({document:V,proof:{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod"}}),X=[{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_.signer.getVerificationMethodId(),created:k,proofPurpose:"assertionMethod",proofValue:w.proofValue}];if(V.proof=X,!await B(V,N.updateKeys,N.witness,!0,_.verifier))throw new Error(`version ${V.versionId} is invalid.`);let q={...N,versionId:V.versionId,updated:V.versionTime,deactivated:!0,updateKeys:x.updateKeys};return{did:V.state.id,doc:V.state,meta:q,log:[...S,V]}};import{canonicalize as w_}from"json-canonicalize";var s=(_)=>{return{type:"DataIntegrityProof",cryptosuite:"eddsa-jcs-2022",verificationMethod:_,created:H(),proofPurpose:"assertionMethod"}},D_=async(_,S)=>{let K=await Z(w_(_)),N=await Z(w_(S));return C(N,K)};class V_{verificationMethod;useStaticId;constructor(_){this.verificationMethod=_.verificationMethod,this.useStaticId=_.useStaticId!==void 0?_.useStaticId:!0}getVerificationMethodId(){return this.useStaticId?`did:key:${this.verificationMethod.publicKeyMultibase}#${this.verificationMethod.publicKeyMultibase}`:this.verificationMethod.id||""}}var H_=(_,S)=>{return async(K)=>{try{let N=s(S),I=await _.sign({document:K,proof:N});return N.proofValue=I.proofValue,{...K,proof:N}}catch(N){throw console.error(N),new Error(`Document signing failure: ${N.message||N}`)}}},M_=(_,S=!0)=>{return console.warn("createSigner is deprecated. Use createDocumentSigner with your own Signer implementation instead."),async(K)=>{try{let N=S?`did:key:${_.publicKeyMultibase}#${_.publicKeyMultibase}`:_.id||"",I=s(N);throw new Error("createSigner is deprecated. Implement your own Signer and use createDocumentSigner instead.")}catch(N){throw console.error(N),new Error(`Document signing failure: ${N.message||N}`)}}};export{F_ as updateDID,M as resolveDIDFromLog,P_ as resolveDID,D_ as prepareDataForSigning,G_ as multibaseEncode,z as multibaseDecode,C_ as deactivateDID,M_ as createSigner,s as createProof,H_ as createDocumentSigner,z_ as createDID,o as MultibaseEncoding,V_ as AbstractCrypto};

 //# debugId=4516D29CEED9D19E64756E2164756E21